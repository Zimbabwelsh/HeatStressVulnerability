library(shiny)
library(shinydashboard)
library(shinycssloaders)
library(sf)
library(pals)
library(ggplot2)
library(biscale)
library(cowplot)

ui <- dashboardPage(
  
  dashboardHeader(title="UK Heat Stress Vulnerability", titleWidth = 300),
  
  dashboardSidebar(
    sidebarMenu(
      menuItem("Mapping", tabName="first", icon = icon("calculator")),
      menuItem("Motivation", tabName="second", icon = icon("book-reader")),
      menuItem("Methods and Metrics", tabName="third", icon = icon("cog", lib = "glyphicon"))
    )
  ),
  
  dashboardBody(
    tabItems(
      tabItem(
        tabName="first",
        fluidRow(column(4, h4("Dataset selection"),
                        selectInput("scenario1", "Climate scenario", 
                                    c("Recent past", "+1.5°C", "+2.0°C", "+3.0°C", "Change (+3.0°C - past)")),
                        selectInput("region", "Region", 
                                    c("UK", "England", "Scotland", "Wales", "Northern Ireland")),
#                        selectInput("gran", "Polygon Resolution",
#                                   c("Low", " High (unavailable online)")),
actionButton("simulate", "Create map", class = "btn-block btn-success"),br(),br(),
actionButton("reset", "Reset default values")
                        
        ),
        column(4,
               h4("Weighting of climate metrics"),
               
               sliderInput(inputId = "num1",
                           label = "Extreme max. temperature",
                           min = 0.0, max = 1,value = 0.32, step = 0.01),
               sliderInput(inputId = "num2",
                           label = "Extreme vapour pressure",
                           min = 0.0, max = 1, value= 0.27, step = 0.01),
               sliderInput(inputId= "num3",
                           label = "Extreme min. temperature",
                           min=0.0, max=1, value=0.19, step=0.01),
               sliderInput(inputId="num4",
                           label="Degree Days",
                           min=0.0, max=1, value=0.22, step=0.01)
        ),
        column(4,
               h4("Weighting of socio-economic metrics"),
               sliderInput(inputId = "num5",
                           label = "Equivalised UK Index of Multiple Deprivation",
                           min = 0.0, max = 1, value = 0.5, step = 0.01),
               sliderInput(inputId = "num6",
                           label = "Proportion of population over the age of 65",
                           min = 0.0, max = 1, value = 0.5, step = 0.01),
               sliderInput(inputId = "num7", 
                           label = "Population density",
                           min = 0.0, max = 1, value = 0.5, step = 0.01)
        ),
        
        # Main panel for displaying outputs ----
        mainPanel(
          column(12, (
            withSpinner(plotOutput(outputId = "biplot"))
          )))
        )
      ),
      
      tabItem(
        tabName="second",
        fluidRow(column(8, 
                        box(width=12, h4("Motivation"),
                            "This app is an interactive supplement to the paper Kennedy-Asser et al., in prep.:", em("Simulated future heat stress risk in UKCP18"), br(), br(),
                            "The UK experiences significant regional increases in mortality in response to summer heatwaves. Projected future warming is expected to increase exposure to heat stress risks. Within the UK, there will be individuals in society that are particularly vulnerable to climate hazards due to socio-economic factors.", br(), br(),
                            "The latest UK Climate Projections (UKCP18) from the UK Met. Office are used here to project changing heat extremes at 12 km spatial resolution for all regions of the UK. Four metrics of heat stress are used to define heat hazards for different warming scenarios. These are combined with three socio-economic metrics which are used to define some key aspects of vulnerability to heat extremes.", br(), br(),
                            "Heat hazard and socio-economic vulnerability factors have been transformed to z-scores and linearly combined. The interaction of these factors is used to highlight spatial hotspots of risk associated with extreme heat, for present and future climate scenarios. This app allows the weighting applied to each of these factors in generating risk maps to be modified and the uncertainty explored. For a full description of the metrics and methods, see the associated paper.")))
      ),
      
      tabItem(tabName = "third",
              fluidRow(column(6,box(width=12,h4("Methods"),
                                    "All climate metrics show the multi-simulation mean from the UKCP18 RCM ensemble (Murphy et al. 2019), bias corrected following the ISIMIP2b method (Lange 2018). The climate scenarios refer to the 30 year period when global temperature first exceeds the given level of warming above pre-industrial temperatures. The ",em("Recent past")," scenario refers to the period 1990-2019. Socio-economic metrics are the same for all climate scenarios.", br(), br(),
                                    "All metrics have been transformed to z-scores and are linearly combined once the user selected weights are applied. The default values for the metric weights were derived from Common Factor Analysis using 1 factor. Other methods (such as Principal Component Analysis) could also be used which would produce different weights. This app allows sensitivity to weightings to be assessed.", br(), br(),
                                    "Note: the z-scores for the scenarios ", em("Recent past"),", ",em("+1.5°C"),", ",em("+2.0°C")," and ",em("+3.0°C")," are calculated individually, therefore they do not show risk relative to other warming levels. To assess the spatial variation in change between warming scenarios, use the ",em("Change (+3.0°C - past)")," scenario."
                
              )),
              column(6,box(width=12,h4("Metrics"),
                           
                           em("Extreme max. temperature"), " is the mean daily maximum temperature on extreme days.", br(),br(),
                           em("Extreme vapour pressure"), "is the mean vapour pressure on extreme days.",br(),br(),
                           em("Extreme min. temperature"), "is the mean daily minimum temperature on extreme days." ,br(),br(), 
                           em("Degree Days"), "is the sum of °C exceeding a threshold of summer daily mean temperature on all days exceeding the threshold." ,br(),br(), 
                           em("Equivalised UK Index of Multiple Deprivation"), " is parameterised from Abel et al. (2016)."  ,br(),br(),
                           em("Proportion of population over the age of 65"), " and ", em("Population density"), " are derived from current population estimates from the ONS, NISRA and NRS.", br(),br(), 
                           "Note: For climate metrics, 'extreme days' are those exceeding the 95th percentile of daily maximum temperature. All climate metrics are calculated for the summer period 1st June - 15th September."
              ))
              ),
              fluidRow(column(12,box(width=12,h4("Further information"),
                                    "Abel et al. 2016: http://dx.doi.org/10.1136/bmjopen-2016-012750",br(),
                                    "Lange 2018: https://www.isimip.org/documents/284/ISIMIP2b_biascorrection_factsheet_24May2018.pdf",br(),
                                    "Murphy et al. 2019: http://www.metoffice.gov.uk/pub/data/weather/uk/UKCP18/science-reports/UKCP18-land-report.pdf",br(),
                                    ))
                              ))
      )))


# Define server logic required to draw a histogram ----
server <- function(input, output) {
  
  # Allow sliders to be reset to default values from paper
  observeEvent(input$reset, {
    updateSliderInput(inputId = "num1", value = 0.32)
    updateSliderInput(inputId = "num2", value = 0.27)
    updateSliderInput(inputId = "num3", value = 0.19)
    updateSliderInput(inputId = "num4", value = 0.22)
    updateSliderInput(inputId = "num5", value = 0.5)
    updateSliderInput(inputId = "num6", value = 0.5)
    updateSliderInput(inputId = "num7", value = 0.5)
  })
  

  # Load the data as reactive variables to update only when 'Create Map' is pressed
  df <- eventReactive(input$simulate, {
    # if (input$gran=="Low"){
      df <- na.omit(sf::st_read("shinydata/polyshiny8.shp"))
    # }
    # else{
    #   df <- na.omit(sf::st_read("shinydata/polyshiny350.shp"))
    # }
    if (input$region=="UK"){
      df <- df
      }
    else if (input$region=="England"){
      id <- substr(df$cd,start = 1, stop = 1) == "E"
      df <- df[id,]
    }
    else if (input$region=="Scotland"){
      id <- substr(df$cd,start = 1, stop = 1) == "S"
      df <- df[id,]
    }
    else if (input$region=="Wales"){
      id <- substr(df$cd,start = 1, stop = 1) == "W"
      df <- df[id,]
    }
    else if (input$region=="Northern Ireland"){
      id <- substr(df$cd,start = 1, stop = 1) == "9"
      df <- df[id,]
    }
    })

  
  # Likewise define climate and social risk as reactive expressions
  climaterisk <- eventReactive(input$simulate, {
  if (input$scenario1=="Recent past"){
      climaterisk <- df()$Tmx95_p*input$num1 + df()$VP95_p*input$num2 + df()$Tmn95_p*input$num3 + df()$DD66_p*input$num4
  }
  else if (input$scenario1=="+1.5°C"){
      climaterisk <- df()$Tmx95_15*input$num1 + df()$VP95_15*input$num2 + df()$Tmn95_15*input$num3 + df()$DD66_15*input$num4
  }
  else if (input$scenario1=="+2.0°C"){
      climaterisk <- df()$Tmx95_20*input$num1 + df()$VP95_20*input$num2 + df()$Tmn95_20*input$num3 + df()$rDD66p*input$num4
  }
  else if (input$scenario1=="+3.0°C"){
      climaterisk <- df()$Tmx95_30*input$num1 + df()$VP95_30*input$num2 + df()$Tmn95_30*input$num3 + df()$DD66_30*input$num4
  }
  else if (input$scenario1=="Change (+3.0°C - past)"){
      climaterisk <- df()$dl_Tmx95*input$num1 + df()$dl_VP95*input$num2 + df()$dl_Tmn95*input$num3 + df()$dl_DD66*input$num4
  }
  })
  # climaterisk  <- eventReactive(input$simulate, {df()$Tmx95_p*input$num1 + df()$VP95_p*input$num2 + df()$Tmn95_p*input$num3 + df()$DD66_p*input$num4})
  socialrisk  <- eventReactive(input$simulate, {df()$scl_imd*input$num5 + df()$scl_age*input$num6 + df()$scl_dns*input$num7})
  
  
  # Read in correct coastline
  c <- eventReactive(input$simulate, {c <- na.omit(sf::st_read("shinydata/uk200.shp"))
  if (input$region=="UK"){c <- c}
  else if (input$region=="England"){
    id2 <- substr(c$ctry19cd,start = 1, stop = 1) == "E"
    c <- c[id2,]
  }
  else if (input$region=="Scotland"){
    id2 <- substr(c$ctry19cd,start = 1, stop = 1) == "S"
    c <- c[id2,]
  }
  else if (input$region=="Wales"){
    id2 <- substr(c$ctry19cd,start = 1, stop = 1) == "W"
    c <- c[id2,]
  }
  else if (input$region=="Northern Ireland"){
    id2 <- substr(c$ctry19cd,start = 1, stop = 1) == "N"
    c <- c[id2,]
  }
  })
  
  # Change location of legend depending on what region is being plotted so not to overlap with map
  leg_loc <- eventReactive(input$simulate, {
  if (input$region=="UK" || input$region=="England"){leg_loc <- "TR"}
  else{leg_loc = "TL"}
  })
  
  
  # Generate the plot
  output$biplot <- renderPlot({
    df2 <- df()
    c2 <- c()
    df2$climaterisk <- climaterisk()
    df2$socialrisk <- socialrisk()
    data <- bi_class(df2, x = climaterisk, y = socialrisk, style = "quantile", dim = 3)
    
    custom_pal <- bi_pal_manual(val_1_1="#e8e8e8", val_1_2 = "#e4d9ac", val_1_3 = "#c8b35a", 
                                val_2_1="#cbb8d7", val_2_2 = "#c8ada0", val_2_3 = "#af8e53",
                                val_3_1="#9972af", val_3_2 = "#976b82", val_3_3 = "#804d36")
    
    map <- ggplot2::ggplot() +
      geom_sf(data = data, mapping = aes(fill = bi_class), colour = NA, show.legend = FALSE) +
      bi_scale_fill(pal = custom_pal, dim = 3) +
      bi_theme() +
      geom_sf(data = c2, fill = NA, size = 0.5)
    
    legend <- bi_legend(pal = custom_pal,
                        dim = 3,
                        xlab = "Climate Hazard",
                        ylab = "Social Vulnerability",
                        size = 8)
    
    # Plot the map, updating the legen location if necessary
    if (leg_loc() =="TR"){
      finalPlot <- cowplot::ggdraw() +
        cowplot::draw_plot(map, 0, 0, 1, 1) +
        cowplot::draw_plot(legend, 0.7, 0.7, 0.3, 0.3)
    }
    else{
      finalPlot <- cowplot::ggdraw() +
        cowplot::draw_plot(map, 0, 0, 1, 1) +
        cowplot::draw_plot(legend, 0, 0.7, 0.3, 0.3)
    }
    
    
    plot(finalPlot)
  })
}

shinyApp(ui, server)

